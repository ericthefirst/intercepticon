// INTERCEPTICON


// Characters
ArrayList<Alien>             aliens;
ArrayList<InterceptLaserPod> i_pods;
InterceptLaserPod            i_pod;

// Controller
Equation   eqn;
Controller c;

// Model
ArrayList<Point> points;
ArrayList<Line>  lines;

// View
View v;


void setup() {
  init_view();
  init_model();
  init_characters();
  init_controller();
}

void draw() {
  advance_characters();
  if(!v.updated)
    return;
  v.draw();
  v.updated = false;
}





// CHARACTERS


void init_characters() {
  aliens = new ArrayList<Alien>();
  create_test_aliens();
  i_pods = new ArrayList<InterceptLaserPod>();
  i_pods.add(new InterceptLaserPod());
  i_pod = i_pods.get(0);
}

void advance_characters() {
  for(Alien a : aliens) {
    a.clock_tick();
  }
} 

String default_spaceship_filename = "/Users/hapless/projects/intercepticon/img/spaceship.png";

void add_test_alien(float x, float y, float period, float offset_sec) {
  aliens.add(new Alien(x,y,period, offset_sec));
}
void create_test_aliens() {
  add_test_alien( 6, 3,  2, .00);
  add_test_alien( -9, -2,  2, .25);
  add_test_alien(-7, 4,  2, .50);
  add_test_alien(3, -4,  2, .75);
  
}
public class Alien {
  PImage spaceship;
  float x;
  float y;
  float dx;
  float dy;
  float[] dxs = {-1, 0};
  float[] dys = {0, -1};
  float epsilon;
  int movement_i  = 0;
  int movement_t = 0;
  int movement_period = 0;
  int dt;
  
  boolean exploding = false;
  
  void init() {
    this.dx = dxs[0];
    this.dy = dys[0];
  }
  
  public Alien(float x, float y, float movement_period_seconds, float movement_offset_seconds) {
    this.x = x;
    this.y = y;
    movement_period = int(60 * movement_period_seconds);
    movement_t      = int(60 * movement_offset_seconds);
    spaceship = loadImage(default_spaceship_filename);
    dt = 1;
    init();
  }
  
  public Alien(String spaceship_filename, float x, float y, float[] dxs, float dys[], int movement_dt, int offset, int dt) {
    this.spaceship = loadImage(spaceship_filename);
    this.x = x;
    this.y = y;
    this.dxs = dxs;
    this.dys = dys;
    this.dx = dxs[0];
    this.dy = dys[0];
    this.movement_period = movement_period;
    this.movement_t = offset;
    this.dt = dt;
  } 
  
  void advance_strategy() {
    movement_i = (movement_i + 1) % (dxs.length);
    dx = dxs[movement_i];
    dy = dys[movement_i];
  }
  
  void move() {
    if(exploding)
      return;
    x += dx;
    y += dy;
    if(x < v.world_l) {
      //print(x + "," + y + " hops to " );
      x = v.world_r - (v.world_l-x);
    }
    if(x > v.world_r) {
      //print(x + "," + y + " hops to " );
      x = v.world_l + (x - v.world_r);
      //println(x + ","  + y);
    }
    if(y < v.world_b)
      y = v.world_t - (v.world_b-y);
    if(y > v.world_t)
      y = v.world_b + (y-v.world_t);
    println(x + "," + y);
    v.updated = true;
  }
  
  void clock_tick() {
    movement_t += dt;
    if(movement_t >= movement_period) {
      move();
      movement_t = 0;
      advance_strategy();
    }
  }
  
  boolean is_near(float x, float y) {
    return dist(x,y,this.x,this.y) < epsilon;
  } 
  
}



public class InterceptLaserPod {
  int m_num = 0;
  int m_den = 1;
  int b_num = 0;
  int b_den = 1;
  
  float x = 0;
  float y = 0;
  float theta = PI/4;
  
  float move_y_coef = 0.8;
  float move_theta_coef = 0.8;
  float y_epsilon = 0.001;
  float theta_epsilon = 0.00001;
  
  boolean active = false;
  boolean b_locked;
  boolean m_locked;

  
  float cannon_theta() {
    if(m_den == 0)
      return PI/2;
    return atan(float(m_num)/m_den);
  }
  
  void fire() {
    lines.add(new Line(float(m_num)/m_den, float(b_num)/b_den));
    for(int i = aliens.size()-1; i >= 0; i--)  {
      Alien a = aliens.get(i);
      boolean destroyed = false;
      for(float x = 0; x <= v.world_r; x++) {
        y = x * float(m_num)/m_den + float(b_num)/b_den;
        if(a.is_near(x,y)) {
          a.exploding = true;
          c.initiate_explosion();
          destroyed = true;
        }
        break;          
      }
      if(destroyed)
        break;
      for(float x = 0; x >= v.world_l; x--) {
        y = x*float(m_num)/m_den + float(b_num)/b_den;
        if(a.is_near(x,y)) {
          a.exploding = true;
          c.initiate_explosion();
        }
        break;          
      }
    } 
  }
  
  
  void activate() {
    active = true;
    b_locked = false;
    m_locked = false;
  }
  
  void update() {
    float dy, dtheta;
    if(!b_locked) {
      dy = (-y + float(b_num)/b_den) * move_y_coef;
      if(abs(dy) < epsilon) {
        y = float(b_num/b_den);
        b_locked = true;
      } else {
        y += dy;
        return;
      }
    } else if(!m_locked) {
      dtheta = (atan(float(m_num)/m_den)-theta) * move_theta_coef;
      if(abs(dtheta) < theta_epsilon) {
        theta = atan(float(m_num)/m_den)-theta;
        m_locked = false;
      } else {
        theta += dtheta;
      }
    } else {
      fire();
      active = false;
    }
  }
  
  void deactivate() {
    active = false;
    lines.remove(0);
  }
  
  void apply_equation(Equation eqn) {
    this.m_num = eqn.m_num;
    this.m_den = eqn.m_den;
    this.b_num = eqn.b_num;
    this.b_den = eqn.b_den;
  }
}





// CONTROLLER

final int NUM = 0;
final int DEN = 1;

void init_controller() {
  eqn = new Equation();
  c   = new Controller();
}

void keyPressed() {
  v.updated = true;
  switch(key) {
    case 'w':
      eqn.change_m(NUM, 1);
      break;
    case 's':
      eqn.change_m(NUM, -1);
      break;
    case 'a':
      eqn.change_m(DEN, -1);
      break;
    case 'd':
      eqn.change_m(DEN, 1);
      break;
    case ENTER: case RETURN:
      i_pod.apply_equation(eqn);
      break;
    case CODED:
      switch(keyCode) {
        case UP: 
          eqn.change_b(NUM, 1);
          break;
        case DOWN:
          eqn.change_b(NUM, -1);
          break; 
        case LEFT: 
          eqn.change_b(DEN, -1);
          break;
        case RIGHT:
          eqn.change_b(DEN, 1);
          break; 
      }
  }
}



public class Equation {
  int m_num = 1;
  int m_den = 2;
  int b_num = 2;
  int b_den = 3;
  
  public Equation() { }

  void change_b(int type, int d) {
    if(type == DEN) {
      b_den += d;
      if(b_den < 1) {
        b_den = 1;
      }
    } else {
      b_num += d;
    }
  }

  
  void change_m(int type, int d) {
    if(type == DEN) {
      m_den += d;
      if(m_den < 1) {
        m_den = 1;
      }
    } else {
      m_num += d;
      if(m_num == 0)
        m_num += d;
    }
  }  
}



public class Controller() {
  // lasers
  int laser_timer = 0;
  int laser_max = 30;
  
  int explosion_timer = 0;
  int explosion_max = 120;
  
  // handle lasers
  
  void initiate_laser() {
    laser_timer = laser_max;
  }
  
  void initiate_explosion() {
    explosion_timer = explosion_max;
  }
  
  void advance_explosion_timer() {
    if(explosion_timer <= 0)
      return;
    explosion_timer -= 1;
    if(explosion_timer <= 0) {
      remove_exploding_aliens();
    }    
  }
  
  void remove_exploding_aliens() {
    for(int i = aliens.size()-1; i >= 0; i--){
      if(aliens.get(i).exploding)
        aliens.remove(i);
    }
  }
  
  
  void advance_laser_timer() {
    if(laser_timer == 0)
      return;
    laser_timer -= 1;
    if(laser_timer <= 0)
      dequeue_line();
  }
  
  void dequeue_line() {
    lines.remove(0);
  } 
}





// MATH

float round_to_multiple(float value, float quanta) {
  return round(value / quanta) * quanta;
} 







// MODEL

void init_model() {
  points = new ArrayList<Point>();
  points.add(new Point(3,4));
}

public class Point {
  float x, y;
  
  public Point(float x, float y) {
    this.x = x;
    this.y = y;
  }
    
}

public class Line {
  float a, b, c;
  
  public Line(float x0, float y0, float x1, float y1) {
    if(x0 == x1) {
      a = 1;
      b = 0;
      c = -x0;
    } else {
      float M = (y1-y0)/(x1-x0);
      float B = y0-M*x0;
      import_from_slope_intercept(M,B);
    }
  }
  
  public Line(float a, float b, float c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  
  public Line(float M, float B) {
    import_from_slope_intercept(M,B);
  }
  
  void import_from_slope_intercept(float M, float B) {
    c = -B;
    a = -M;
  }
  
}




// VIEW

void init_view() {
  size(1200, 800);
  ellipseMode(RADIUS); 
  v = new View(-10.5, 10.5, -5.5, 5.5);
  textFont(createFont("Helvetica", 30));
  imageMode(CENTER);
  strokeCap(SQUARE);
}

public class View {
  color BG_C     = color(216);
  color MARGIN_C = color(64);
  color EQN_BG_C = color(216);

  float MARGIN = 20;
  boolean updated = true;
  
  final int WORLD    = 0;
  final int SCR      = 1;
  final int TO_WORLD = 0;
  final int TO_SCR   = 1;
  
  final int X_AXIS = 0;
  final int Y_AXIS = 1;

  float world_l, world_r, world_t, world_b;
  float scr_l,   scr_r,   scr_t,   scr_b;
  
  float eqn_l,   eqn_r,   eqn_t,   eqn_b;
  
  color eqn_text_c       = color(25, 25,0);
  float eqn_text_h       = 40;
  float eqn_text_margin; // defined in constructor
  float eqn_text_kern    = 10;
  float eqn_coef_kern    = 5;
  
  float eqn_frac_text_h  = 30;
  float eqn_frac_sw      = 4;
  float eqn_frac_pad_top = -3;
  float eqn_frac_pad_bot = 2;
  float eqn_frac_len_ext = 5;
  float eqn_vertical_ff  = -5; 
  
  color pt_c = color(0,0,255);
  float pt_r = 3;

  color line_c  = color(0,255,0);
  float line_sw = 1;
  
  color axis_c  = color(0);
  float axis_sw = 3;
  
  color tick_c         = color(0);
  float tick_sw        = 1;
  float tick_len       = 8;
  float tick_spacing_x = 1;
  float tick_spacing_y = 1;
  
  color tick_text_c  = color(0);
  float tick_text_h   = 15;
  float tick_text_pad = 10;
  
  color explosion_c         = color(216, 0, 0);
  int   num_explosion_lines = 8;
  float explosion_line_len  = 10;
  float explosion_start_r   = 10;
  float explosion_end_r     = 50;
  
  color ipod_c  = color(255,128,0);
  float ipod_r  = 20;
  float ipod_cannon_w = 5;
  float ipod_cannon_l = 10;


  public View(float world_l, float world_r, float world_b, float world_t) {
    set_window(WORLD, world_l, world_r, world_b, world_t);
    float asp = aspect_ratio(WORLD);
    set_window(SCR, MARGIN, width-MARGIN, width/asp-MARGIN, MARGIN);
  }

  public View() {
    set_window(SCR, MARGIN , width-MARGIN, height-MARGIN, MARGIN);
    float asp = aspect_ratio(SCR);
    set_window(WORLD, -10*asp, 10*asp, -10, 10);
  }
  
  /////////////
  // DRAWING //
  /////////////

  void draw() {
    draw_bg();
    draw_axes();
    for(Point p : points)
      draw_point(p);
    for(Alien a : aliens)
      draw_alien(a);
    draw_equation(eqn);
  }
  
  void draw_bg() {
    background(MARGIN_C);
    noStroke();
    fill(BG_C);
    rect(scr_l, scr_t, scr_r-scr_l, scr_b-scr_t);
    fill(EQN_BG_C);
    rect(eqn_l, eqn_t, eqn_r-eqn_l, eqn_b-eqn_t);
    
  }

  void draw_axes() {
    draw_line(0, world_b, 0, world_t, axis_c, axis_sw);
    draw_line(world_l, 0, world_r, 0, axis_c, axis_sw);
    draw_ticks();
  }
  
  void draw_ticks() {
    textAlign(CENTER, BOTTOM);   // later, handle axis off screen
    textSize(tick_text_h);
    strokeWeight(tick_sw);
    fill(tick_text_c);
    String lbl;

    // X_AXIS
    float y = max(0, world_b);
    textAlign(CENTER, TOP);
    for(float x = round_to_multiple(world_l, tick_spacing_x); x <= world_r; x += tick_spacing_x) {
      if(abs(x-int(x)) < 0.001)
        lbl = ""+int(x);
      else
        lbl = ""+x;
      draw_tick(x,y, X_AXIS, lbl);
    }

    // Y_AXIS
    float x = max(0, world_l);
    textAlign(RIGHT, CENTER);
    for(y = round_to_multiple(world_b, tick_spacing_y); y <= world_t; y += tick_spacing_y) {
      lbl = (abs(y-int(y)) < 0.001) ?  ""+int(y): ""+y;
      draw_tick(x,y, Y_AXIS, lbl);
    }
    
  }
  
  void draw_tick(float x, float y, int type, String label) {
    float scr_x = scale_x(x, TO_SCR);
    float scr_y = scale_y(y, TO_SCR);
    if(type == X_AXIS) {
      stroke(tick_c);
      line(scr_x, scr_y - tick_len/2, scr_x, scr_y+tick_len/2);
      noStroke();
      if(x != 0)
        text(label, scr_x, scr_y + tick_len/2 + tick_text_pad); 
    } else {
      stroke(tick_c);
      line(scr_x-tick_len/2, scr_y, scr_x+tick_len/2, scr_y);
      noStroke();
      if(y != 0)
        text(label, scr_x - tick_text_pad, scr_y);
    }
  }

  void draw_point(Point p) {
    float x = scale_x(p.x, TO_SCR);
    float y = scale_y(p.y, TO_SCR);
    fill(pt_c);  
    noStroke();
    ellipse(x,y,pt_r, pt_r);    
  }
  
  // TODO: Rename this mess
  void draw_line(float x0, float y0, float x1, float y1) {
    draw_line(x0, y0, x1, y1, line_c, line_sw);
  }
  
  void draw_line(float x0, float y0, float x1, float y1, color c, float sw) {
    x0 = scale_x(x0, TO_SCR);
    y0 = scale_y(y0, TO_SCR);
    x1 = scale_x(x1, TO_SCR);
    y1 = scale_y(y1, TO_SCR);
    stroke(c);
    strokeWeight(sw);
    line(x0, y0, x1, y1);
  }
  
  void draw_line(Line l) {
    draw_line_segment(l, world_l, world_r);
  }
  
  void draw_line_segment(Line l, float x_l, float x_r) {
      if(l.b == 0) {
        float x = -l.c/l.a;
        if(x > x_r || x < x_l)
          return;
        draw_line(x, world_b, x, world_t);
        return;
    }
    float m = -(l.c+l.a)/l.b;
    float b = -l.c/l.b;
    draw_line(x_l, m*x_l+b, x_r, m*x_r+b);
  }
  
  
  void draw_alien(Alien a) {
    float scr_x = scale_x(a.x, TO_SCR);
    float scr_y = scale_y(a.y, TO_SCR);
    if(a.exploding)
      draw_explosion(scr_x, scr_y, c.explosion_timer);
    else
      image(a.spaceship, scr_x, scr_y);
  }
  
  void draw_explosion(float scr_x, float scr_y, int timer) {
    float r = (explosion_start_r-explosion_end_r)/c.explosion_max * (c.explosion_max-timer);
    stroke(explosion_c);
    for(int i = 0; i < num_explosion_lines; i++) {
      float x0 = scr_x + r*cos(2*PI*i/num_explosion_lines)
      float y0 = scr_x + r*sin(2*PI*i/num_explosion_lines)
      float x1 = scr_x + (r+explosion_line_len*cos(2*PI*i/num_explosion_lines);
      float y1 = scr_x + (r+explosion_line_len*sin(2*PI*i/num_explosion_lines);
      line(x0,y0,x1,y1);
    }
  }
  
  void draw_ipod(InterceptLaserPod ipod) {
    float scr_x = scale_x(ipod.x, TO_SCR);
    float scr_y = scale_y(ipod.y, TO_SCR);
    noStroke();
    fill(ipod_c);
    ellipse(scr_x, scr_y, ipod_r, ipod_r);
    float x1 = scr_x + ipod_cannon_l * cos(theta);
    float y1 = scr_y + ipod_cannon_l * sin(theta);
    strokeWeight(ipod_cannon_w);
    line(scr_x, scr_y, x1, y1);    
  }

  void draw_equation(Equation eqn) {
    
//      float eqn_l,   eqn_r,   eqn_t,   eqn_b;

    float eqn_y = (eqn_t + eqn_b)/2 + eqn_vertical_ff; 
    float eqn_x;
     
    textSize(eqn_text_h);
    noStroke();
    fill(eqn_text_c);
    textAlign(CENTER, CENTER);
    
    eqn_x = eqn_l + eqn_text_margin + textWidth("y")/2;
    println("eqn_x = " + eqn_l + " + " + eqn_text_margin + " + " + (textWidth("y")/2));
    println("eqn at " + eqn_x + "," + eqn_y);
    text("y", eqn_x, eqn_y);
    
    eqn_x +=  textWidth("y")/2 + eqn_text_kern + textWidth("=")/2;
    text("=", eqn_x, eqn_y);
    eqn_x += textWidth("=")/2 + eqn_text_kern; 
    
    if(eqn.m_num != 0) {
      if(eqn.m_den != 1) {
        eqn_y -= eqn_vertical_ff;
        float m_width = textWidth(""+eqn.m_num);
        if(m_width < textWidth(""+eqn.m_den))
          m_width = textWidth(""+eqn.m_den);
        m_width += eqn_frac_len_ext;
        
        eqn_x += m_width / 2;
        strokeWeight(eqn_frac_sw);
        stroke(eqn_text_c);
        line(eqn_x-m_width/2, eqn_y, eqn_x+m_width/2, eqn_y);
        noStroke();
        
        textSize(eqn_frac_text_h);
        textAlign(CENTER, BOTTOM);
        text(eqn.m_num, eqn_x, eqn_y - eqn_frac_pad_top - eqn_frac_sw/2);
        textAlign(CENTER, TOP);
        text(eqn.m_den, eqn_x, eqn_y + eqn_frac_pad_bot + eqn_frac_sw/2);
        
        eqn_x += m_width/2 + eqn_coef_kern + textWidth("x") / 2;
        textAlign(CENTER, CENTER); 
        eqn_y += eqn_vertical_ff;
      } else {
        eqn_x += textWidth(""+eqn.m_num)/2;
        text(eqn.m_num, eqn_x, eqn_y);
        eqn_x += textWidth(""+eqn.m_num)/2 + eqn_coef_kern + textWidth("x")/2;
      }
      textSize(eqn_text_h);
      text("x", eqn_x, eqn_y);
      if(eqn.b_num == 0)
        return;
      eqn_x += textWidth("x")/2 + eqn_text_kern + textWidth("+")/2;
      text("+", eqn_x, eqn_y);
      eqn_x += textWidth("+")/2 + eqn_text_kern;
    }
    
    if(eqn.b_den != 1 && eqn.b_num != 0) {   
     eqn_y -= eqn_vertical_ff;     
      float b_width = textWidth(""+eqn.b_num);
      if(b_width < textWidth(""+eqn.b_den))
        b_width = textWidth(""+eqn.b_den);
      b_width += eqn_frac_len_ext;
      
      eqn_x += b_width / 2;
      strokeWeight(eqn_frac_sw);
      stroke(eqn_text_c);
      line(eqn_x-b_width/2, eqn_y, eqn_x+b_width/2, eqn_y);
      noStroke();

      textSize(eqn_frac_text_h);
      textAlign(CENTER, BOTTOM);
      text(eqn.b_num, eqn_x, eqn_y - eqn_frac_pad_top - eqn_frac_sw/2);
      textAlign(CENTER, TOP);
      text(eqn.b_den, eqn_x, eqn_y + eqn_frac_pad_bot + eqn_frac_sw/2);
      eqn_y += eqn_vertical_ff; 
    } else {
      eqn_x += textWidth(""+eqn.b_num)/2;
      text(eqn.b_num, eqn_x, eqn_y);
    }
  }
  
  ///////////////////////
  // COORDINATE SYSTEM //
  ///////////////////////  
  
  void set_window(int type, float l, float r, float b, float t) {
    if(type == WORLD) {
      world_l = l; 
      world_r = r; 
      world_b = b; 
      world_t = t; 
    } else if (type == SCR) {
      scr_l = l; 
      scr_r = r; 
      scr_b = b;
      scr_t = t; 
      eqn_l = l;
      eqn_r = r;
      eqn_t = scr_b  + MARGIN;
      eqn_b = height - MARGIN;
      eqn_text_margin = (eqn_b-eqn_t - eqn_text_h) / 2;
    }  
  }
  
  float aspect_ratio(int type) {
    if(type == SCR)
      return abs((scr_r-scr_l)/(scr_t-scr_b));
    else
      return abs((world_r-world_l)/(world_t-world_b));
  }

  float scale_x(float x0, int type) {
    if(type == TO_WORLD) {
      float extent = (x0-scr_l) / (scr_r-scr_l);
      return extent * (world_r-world_l) + world_l;
    } else {
      float extent = (x0-world_l) / (world_r-world_l);
      return extent * (scr_r-scr_l) + scr_l;
    }
  }

  float scale_y(float y0, int type) {
    if(type == TO_WORLD) {
      float extent = (y0-scr_b) / (scr_t-scr_b);
      return extent * (world_t-world_b) + world_b;
    } else {
      float extent = (y0-world_b) / (world_t-world_b);
      return extent * (scr_t-scr_b) + scr_b;
    }
  }

    
  
}



